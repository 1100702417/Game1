<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>‡πÄ‡∏Å‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô 3D - Bitkub Chain</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Three.js ‡πÅ‡∏•‡∏∞ OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.8.2/dist/web3.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #connectButton {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #2e8b57;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #connectButton:hover {
      background-color: #256c45;
    }
  </style>
</head>
<body>

  <button id="connectButton">üîó ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MetaMask</button>

  <script>
    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MetaMask
    document.getElementById("connectButton").addEventListener("click", async () => {
      if (window.ethereum) {
        const web3 = new Web3(window.ethereum);
        try {
          const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
          const netId = await web3.eth.net.getId();
          if (netId !== 96) {
            alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Bitkub Chain Mainnet (Chain ID: 96)");
          } else {
            alert("‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: " + accounts[0]);
          }
        } catch (error) {
          alert("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏£‡∏∞‡πÄ‡∏õ‡πã‡∏≤‡πÑ‡∏î‡πâ");
        }
      } else {
        alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á MetaMask ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
      }
    });

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á scene 3D
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ô‡πâ‡∏≥
    const waterGeometry = new THREE.PlaneGeometry(100, 100);
    const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x4fc3f7 });
    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI / 2;
    water.position.y = -3;
    scene.add(water);

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Å‡∏≤‡∏∞‡πÅ‡∏ö‡∏ö‡∏ß‡∏á‡∏£‡∏µ (‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô)
    const islandGeometry = new THREE.SphereGeometry(4, 64, 64);
    const islandMaterial = new THREE.MeshStandardMaterial({ color: 0x8bc34a, flatShading: true });
    const island = new THREE.Mesh(islandGeometry, islandMaterial);
    island.scale.y = 0.3;
    island.rotation.x = Math.PI / 2;
    scene.add(island);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô 5 ‡∏à‡∏∏‡∏î (‡πÄ‡∏õ‡πá‡∏ô plot ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏•‡∏¥‡∏Å)
    const plotPositions = [
      [2, -1.5, 0],
      [-2, -1.5, 0],
      [0, -1.5, 2],
      [0, -1.5, -2],
      [0, 0, 0],
    ];

    plotPositions.forEach((pos, index) => {
      const plot = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.2, 1),
        new THREE.MeshStandardMaterial({ color: 0xffeb3b })
      );
      plot.position.set(...pos);
      plot.userData = { id: index + 1 };
      scene.add(plot);
    });

    // ‡πÅ‡∏™‡∏á
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(5, 10, 5);
    scene.add(sun);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà plot
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children);

      for (let i = 0; i < intersects.length; i++) {
        const obj = intersects[i].object;
        if (obj.userData.id) {
          alert("‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡πÅ‡∏õ‡∏•‡∏á: " + obj.userData.id);
          break;
        }
      }
    });

    // responsive
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ‡∏ß‡∏ô‡∏†‡∏≤‡∏û
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
